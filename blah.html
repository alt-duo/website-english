<!--
Calendly-like Scheduler
Single-file project: index.html contains the frontend UI and also includes the exact server.js contents (hidden in a <script> block) and README.

What you get:
 - index.html -> Frontend UI (vanilla HTML/CSS/JS) using fetch() to call backend endpoints
 - server.js  -> Minimal Express backend using sqlite3 for persistence and simple business logic
 - README instructions in comments show how to extract server.js and run locally

Features:
 - Shows available 30-minute time slots for the next 14 days (9:00 - 17:00 local time)
 - Loads existing bookings from SQLite and marks slots as "booked"
 - Creates new bookings and prevents double-booking via UNIQUE constraint
 - Simple input for name & email when booking a slot
 - All code is runnable on a normal browser domain (http://localhost:3000)

Security & production notes:
 - This is a demo. Add validation, authentication, rate limiting, HTTPS, email confirmations, CSRF protection, and production DB before using publicly.
 - To integrate with Google Calendar / Outlook, add OAuth flows and webhooks.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Easy Scheduler — Demo</title>
  <style>
    :root{--bg:#f4f6fb;--card:#ffffff;--accent:#2563eb;--muted:#6b7280}
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:var(--bg); margin:0}
    header{background:linear-gradient(90deg,#0f172a,#0b1220);color:#fff;padding:18px 24px}
    .wrap{max-width:980px;margin:20px auto;padding:0 16px}
    h1{margin:0;font-size:20px}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:20px;margin-top:18px}
    .card{background:var(--card);padding:16px;border-radius:10px;box-shadow:0 8px 30px rgba(2,6,23,0.06)}
    .slot{padding:8px 10px;border-radius:8px;margin:6px 0;display:flex;justify-content:space-between;align-items:center;border:1px solid #eef2ff}
    .slot.free{cursor:pointer}
    .slot.booked{background:#f8fafc;color:var(--muted);border:1px dashed #e6edf8}
    .btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    label{font-size:13px;color:var(--muted);display:block;margin-top:10px}
    input{width:100%;padding:8px;border-radius:8px;border:1px solid #e6eefb;margin-top:6px}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px;color:var(--muted)}
    .slots-list{max-height:560px;overflow:auto;padding-right:6px}
  </style>
</head>
<body>
  <header>
    <div class="wrap" style="display:flex;align-items:center;justify-content:space-between">
      <div>
        <h1>Easy Scheduler — Demo</h1>
        <div class="small">Schedule 1-on-1 timeslots. Backend stores bookings locally (SQLite).</div>
      </div>
      <div class="small">Run locally: <span class="muted">http://localhost:3000</span></div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <div>
        <div class="card">
          <h3 style="margin:0 0 8px 0">Available time slots (next 14 days)</h3>
          <div class="muted" id="tzInfo">Loading...</div>
          <hr style="margin:12px 0">
          <div class="slots-list" id="slots"></div>
        </div>
      </div>

      <aside>
        <div class="card">
          <h3 id="bookingTitle">Select a slot</h3>
          <div class="muted" id="slotHelp">Click a free slot to begin booking.</div>

          <div id="bookingForm" style="display:none;margin-top:10px">
            <label for="name">Your name</label>
            <input id="name" placeholder="Full name" />
            <label for="email">Email</label>
            <input id="email" placeholder="you@example.com" />
            <div style="display:flex;gap:8px;margin-top:12px">
              <button id="confirmBtn" class="btn">Confirm booking</button>
              <button id="cancelBtn" style="padding:8px 12px;border-radius:8px;border:1px solid #e6eefb;background:#fff;cursor:pointer">Cancel</button>
            </div>
            <div id="formMsg" class="small" style="margin-top:8px"></div>
          </div>

          <div id="bookingResult" style="display:none;margin-top:8px"></div>
        </div>

        <div class="card" style="margin-top:12px">
          <h4 style="margin:0">Admin</h4>
          <div class="small muted">Quick actions for testing</div>
          <hr style="margin:8px 0">
          <button id="refreshBtn" class="btn" style="width:100%">Refresh slots</button>
          <div style="margin-top:8px">
            <button id="dumpBtn" style="width:100%;padding:8px;border-radius:8px;border:1px solid #e6eefb;background:#fff">List bookings (console)</button>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <script>
    // ---------- Client-side scheduler logic ----------
    const API = '/api';
    const slotsEl = document.getElementById('slots');
    const tzInfo = document.getElementById('tzInfo');
    const bookingForm = document.getElementById('bookingForm');
    const bookingTitle = document.getElementById('bookingTitle');
    const slotHelp = document.getElementById('slotHelp');
    const bookingResult = document.getElementById('bookingResult');
    const nameInput = document.getElementById('name');
    const emailInput = document.getElementById('email');
    const confirmBtn = document.getElementById('confirmBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    let selectedSlot = null; // ISO string start

    function el(tag, attrs={}, txt='') { const e=document.createElement(tag); for(let k in attrs) e.setAttribute(k, attrs[k]); e.textContent = txt; return e; }

    function formatLocal(iso) {
      const d = new Date(iso);
      return d.toLocaleString([], {weekday:'short', month:'short', day:'numeric', hour:'numeric', minute:'2-digit'});
    }

    async function fetchSlots() {
      slotsEl.innerHTML = 'Loading...';
      try {
        const res = await fetch(API + '/slots');
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        renderSlots(data);
      } catch (err) {
        slotsEl.innerHTML = '<div class="small muted">Failed to load slots: '+err.message+'</div>';
        console.error(err);
      }
    }

    function renderSlots(days) {
      slotsEl.innerHTML = '';
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      tzInfo.textContent = 'Times shown in your browser timezone: ' + tz;

      days.forEach(day => {
        const dayWrap = document.createElement('div');
        dayWrap.style.marginBottom = '12px';
        const dayHeader = el('div', {}, day.label + ' — ' + day.date);
        dayHeader.style.fontWeight = '600'; dayHeader.style.marginTop = '8px';
        dayWrap.appendChild(dayHeader);

        day.slots.forEach(s => {
          const slotEl = document.createElement('div');
          slotEl.className = 'slot ' + (s.booked ? 'booked' : 'free');

          const left = document.createElement('div');
          left.textContent = formatLocal(s.start);
          const right = document.createElement('div');
          right.textContent = s.booked ? 'Booked' : 'Book';

          slotEl.appendChild(left);
          slotEl.appendChild(right);

          if (!s.booked) {
            slotEl.addEventListener('click', () => selectSlot(s.start));
          }

          dayWrap.appendChild(slotEl);
        });

        slotsEl.appendChild(dayWrap);
      });
    }

    function selectSlot(isoStart) {
      selectedSlot = isoStart;
      bookingTitle.textContent = 'Book ' + formatLocal(isoStart);
      slotHelp.textContent = '';
      bookingForm.style.display = 'block';
      bookingResult.style.display = 'none';
      nameInput.value = '';
      emailInput.value = '';
      document.getElementById('formMsg').textContent = '';
      window.scrollTo({top:0,behavior:'smooth'});
    }

    cancelBtn.addEventListener('click', () => {
      selectedSlot = null; bookingForm.style.display = 'none'; bookingTitle.textContent = 'Select a slot'; slotHelp.textContent = 'Click a free slot to begin booking.'; bookingResult.style.display = 'none';
    });

    confirmBtn.addEventListener('click', async () => {
      const name = nameInput.value.trim();
      const email = emailInput.value.trim();
      const msg = document.getElementById('formMsg');
      msg.textContent = '';
      if (!selectedSlot) return msg.textContent = 'No slot selected.';
      if (!name || !email) return msg.textContent = 'Enter name and email.';
      confirmBtn.disabled = true; confirmBtn.textContent = 'Booking...';
      try {
        const res = await fetch(API + '/book', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name, email, start: selectedSlot }) });
        if (res.status === 409) {
          const txt = await res.text(); throw new Error(txt || 'Slot already booked');
        }
        if (!res.ok) throw new Error(await res.text());
        const booking = await res.json();
        bookingResult.style.display = 'block'; bookingResult.innerHTML = `<div class="small">Booked! Confirmation ID: <strong>${booking.id}</strong></div>`;
        bookingForm.style.display = 'none';
        fetchSlots();
      } catch (err) {
        msg.textContent = 'Failed: ' + err.message;
        console.error(err);
      } finally {
        confirmBtn.disabled = false; confirmBtn.textContent = 'Confirm booking';
      }
    });

    document.getElementById('refreshBtn').addEventListener('click', fetchSlots);
    document.getElementById('dumpBtn').addEventListener('click', async () => {
      const res = await fetch(API + '/bookings');
      console.log('Bookings:', await res.json());
      alert('Bookings dumped to console.');
    });

    // load on start
    fetchSlots();
  </script>

  <!--
  ------------------ server.js (copy this into server.js in the same folder) ------------------
  Save the following JavaScript into server.js and run:
    npm init -y
    npm install express sqlite3 body-parser
    node server.js

  The backend exposes:
    GET  /api/slots     -> returns next 14 days of 30-min slots with booked flags
    POST /api/book      -> body { name, email, start } -> creates booking, prevents double-booking
    GET  /api/bookings  -> returns all bookings (admin/debug)

  NOTE: This demo uses a simple UNIQUE constraint on start_time to avoid double-booking.
  In production, you should use transactions, validation, rate-limiting, and authentication.
  -----------------------------------------------------------------------------
  -->

  <script type="text/plain" id="serverjs">
const express = require('express');
const fs = require('fs');
const path = require('path');
const bodyParser = require('body-parser');
const sqlite3 = require('sqlite3').verbose();

const DB_PATH = path.join(__dirname, 'bookings.db');
const app = express();
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, '.')));

// init sqlite DB
const db = new sqlite3.Database(DB_PATH);
db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS bookings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    start_time TEXT NOT NULL UNIQUE,
    created_at TEXT NOT NULL
  )`);
});

// helper: generate slots between 9:00 and 17:00 every 30 minutes for next N days
function generateSlots(days=14, startHour=9, endHour=17, intervalMin=30, tzOffsetMinutes=0) {
  const results = [];
  const now = new Date();
  for (let d = 0; d < days; d++) {
    const day = new Date(now.getFullYear(), now.getMonth(), now.getDate() + d);
    const dateLabel = day.toLocaleDateString();
    const slots = [];
    for (let hour = startHour; hour < endHour; hour++) {
      for (let m = 0; m < 60; m += intervalMin) {
        const slot = new Date(day.getFullYear(), day.getMonth(), day.getDate(), hour, m);
        // only future slots
        if (slot.getTime() <= now.getTime()) continue;
        slots.push(slot.toISOString());
      }
    }
    if (slots.length) results.push({ date: dateLabel, label: day.toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' }), slots });
  }
  return results;
}

// GET /api/slots -> returns structured days with slots and booked flag
app.get('/api/slots', (req, res) => {
  const days = 14;
  const generated = generateSlots(days);
  // flatten list of starts
  const allStarts = generated.flatMap(d => d.slots);
  if (allStarts.length === 0) return res.json([]);

  // query bookings that match these start times
  const placeholders = allStarts.map(() => '?').join(',');
  const sql = `SELECT start_time FROM bookings WHERE start_time IN (${placeholders})`;
  db.all(sql, allStarts, (err, rows) => {
    if (err) return res.status(500).send(err.message);
    const booked = new Set(rows.map(r => r.start_time));
    // map back into days with slot objects
    const daysOut = generated.map(d => ({ date: d.date, label: d.label, slots: d.slots.map(s => ({ start: s, booked: booked.has(s) })) }));
    res.json(daysOut);
  });
});

// POST /api/book -> { name, email, start }
app.post('/api/book', (req, res) => {
  const { name, email, start } = req.body;
  if (!name || !email || !start) return res.status(400).send('name, email, and start are required');
  // Basic validation: ensure start is an ISO date and in the future
  const st = new Date(start);
  if (isNaN(st.getTime())) return res.status(400).send('invalid start');
  if (st.getTime() <= Date.now()) return res.status(400).send('start must be in the future');

  const createdAt = new Date().toISOString();
  const stmt = db.prepare('INSERT INTO bookings (name, email, start_time, created_at) VALUES (?, ?, ?, ?)');
  stmt.run(name, email, start, createdAt, function(err) {
    if (err) {
      // UNIQUE constraint failed -> double-booked
      if (err.message && err.message.includes('UNIQUE')) return res.status(409).send('slot already booked');
      return res.status(500).send('database error: ' + err.message);
    }
    const id = this.lastID;
    res.json({ id, name, email, start, createdAt });
  });
});

// GET /api/bookings -> list all bookings (for debug/admin)
app.get('/api/bookings', (req, res) => {
  db.all('SELECT id, name, email, start_time AS start, created_at AS createdAt FROM bookings ORDER BY start_time', [], (err, rows) => {
    if (err) return res.status(500).send(err.message);
    res.json(rows);
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));
  </script>

  <!-- README: Quick run instructions
    1) Save this file as index.html in a new folder.
    2) Extract the server.js contents: copy the text inside the <script id="serverjs"> block and save it as server.js
    3) Run:
         npm init -y
         npm install express sqlite3 body-parser
         node server.js
    4) Open http://localhost:3000 in your browser.

    Improvements you may want:
      - Add email confirmations (e.g., nodemailer)
      - Integrate with Google Calendar (OAuth + Calendar API)
      - Add CAPTCHA or rate-limiting to prevent spam
      - Add user accounts so each organizer has separate calendars
  -->
</body>
</html>
